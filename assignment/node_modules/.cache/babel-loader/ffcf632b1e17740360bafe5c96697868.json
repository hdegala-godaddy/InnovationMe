{"ast":null,"code":"//Make sure that it is a SingleTon object by returing IFFE\nlet ThresholdFetchService = function () {\n  let threshold = 100;\n  let pendingQ = []; // This should rather be a linkedlist, for o(1) retreival\n\n  let currentRequestCount = 0;\n\n  function fetch(empID) {\n    return new Promise((resolve, reject) => {\n      if (currentRequestCount < threshold) {\n        currentRequestCount++; //Here you need to make backend call\n\n        setTimeout(() => handleFetchCalls(resolve, reject, empID), 100);\n      } else {\n        pendingQ.push({\n          empID,\n          resolve,\n          reject\n        });\n      }\n    });\n  }\n\n  function handleFetchCalls(empID, resolve, reject) {\n    let report = [];\n\n    for (let i = 0; i < 200; i++) {\n      report.push(empID * 2 + i);\n    }\n\n    currentRequestCount--;\n    callPendingQueue();\n    resolve({\n      id: empID,\n      name: \"XYZ \" + empID,\n      reports: empID > 2000 ? [] : report\n    });\n  }\n\n  function callPendingQueue() {\n    if (pendingQ.length > 1) {\n      //This is an o(n) operation instead if we \n      //have used linked-list it could be \n      //o(1) operation.\n      let latestReqObject = pendingQ.shift(); //This is important as this should be done\n      //in event-loop context, that would make sure that\n      //this does not go for stack overflow\n\n      currentRequestCount++;\n      setTimeout(() => {\n        handleFetchCalls(...latestReqObject);\n      }, 100);\n    }\n  }\n\n  return {\n    fetch\n  };\n}();\n\nexport default ThresholdFetchService;","map":{"version":3,"sources":["/Users/harshadegala/Code/React/assignment/src/ThresholdFetchService.js"],"names":["ThresholdFetchService","threshold","pendingQ","currentRequestCount","fetch","empID","Promise","resolve","reject","setTimeout","handleFetchCalls","push","report","i","callPendingQueue","id","name","reports","length","latestReqObject","shift"],"mappings":"AAAA;AACA,IAAIA,qBAAqB,GAAI,YAAW;AAEpC,MAAIC,SAAS,GAAG,GAAhB;AACA,MAAIC,QAAQ,GAAG,EAAf,CAHoC,CAGjB;;AACnB,MAAIC,mBAAmB,GAAG,CAA1B;;AAEA,WAASC,KAAT,CAAeC,KAAf,EAAqB;AACjB,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC,UAAIL,mBAAmB,GAAIF,SAA3B,EAAqC;AACjCE,QAAAA,mBAAmB,GADc,CAEjC;;AACAM,QAAAA,UAAU,CAAC,MAAMC,gBAAgB,CAACH,OAAD,EAAUC,MAAV,EAAkBH,KAAlB,CAAvB,EAAiD,GAAjD,CAAV;AACH,OAJD,MAIO;AACHH,QAAAA,QAAQ,CAACS,IAAT,CAAc;AACVN,UAAAA,KADU;AAEVE,UAAAA,OAFU;AAGVC,UAAAA;AAHU,SAAd;AAKH;AACJ,KAZM,CAAP;AAcH;;AAED,WAASE,gBAAT,CAA0BL,KAA1B,EAAgCE,OAAhC,EAAwCC,MAAxC,EAA+C;AAE3C,QAAII,MAAM,GAAG,EAAb;;AAEA,SAAI,IAAIC,CAAC,GAAE,CAAX,EAAeA,CAAC,GAAG,GAAnB,EAAwBA,CAAC,EAAzB,EAA6B;AACzBD,MAAAA,MAAM,CAACD,IAAP,CAAYN,KAAK,GAAC,CAAN,GAAUQ,CAAtB;AACH;;AACDV,IAAAA,mBAAmB;AACnBW,IAAAA,gBAAgB;AAChBP,IAAAA,OAAO,CAAC;AACJQ,MAAAA,EAAE,EAAGV,KADD;AAEJW,MAAAA,IAAI,EAAG,SAASX,KAFZ;AAGJY,MAAAA,OAAO,EAAGZ,KAAK,GAAG,IAAR,GAAe,EAAf,GAAqBO;AAH3B,KAAD,CAAP;AAKH;;AAED,WAASE,gBAAT,GAA2B;AAEvB,QAAIZ,QAAQ,CAACgB,MAAT,GAAkB,CAAtB,EAAyB;AACrB;AACA;AACA;AACA,UAAIC,eAAe,GAAGjB,QAAQ,CAACkB,KAAT,EAAtB,CAJqB,CAKrB;AACA;AACA;;AACAjB,MAAAA,mBAAmB;AACnBM,MAAAA,UAAU,CAAC,MAAM;AACbC,QAAAA,gBAAgB,CAAC,GAAGS,eAAJ,CAAhB;AACH,OAFS,EAER,GAFQ,CAAV;AAGH;AAEJ;;AAED,SAAO;AACHf,IAAAA;AADG,GAAP;AAGH,CA5D2B,EAA5B;;AA+DA,eAAeJ,qBAAf","sourcesContent":["//Make sure that it is a SingleTon object by returing IFFE\nlet ThresholdFetchService = (function (){\n    \n    let threshold = 100;\n    let pendingQ = []; // This should rather be a linkedlist, for o(1) retreival\n    let currentRequestCount = 0;\n\n    function fetch(empID){\n        return new Promise((resolve, reject) => {\n            if (currentRequestCount  < threshold){\n                currentRequestCount++;\n                //Here you need to make backend call\n                setTimeout(() => handleFetchCalls(resolve, reject, empID), 100)\n            } else {\n                pendingQ.push({\n                    empID,\n                    resolve,\n                    reject\n                })\n            }\n        })\n        \n    }\n\n    function handleFetchCalls(empID,resolve,reject){\n\n        let report = [];\n\n        for(let i =0 ; i < 200; i++) {\n            report.push(empID*2 + i);\n        }\n        currentRequestCount--;\n        callPendingQueue();\n        resolve({\n            id : empID,\n            name : \"XYZ \" + empID,\n            reports : empID > 2000 ? [] :  report\n        });\n    }\n\n    function callPendingQueue(){\n\n        if (pendingQ.length > 1) {\n            //This is an o(n) operation instead if we \n            //have used linked-list it could be \n            //o(1) operation.\n            let latestReqObject = pendingQ.shift();\n            //This is important as this should be done\n            //in event-loop context, that would make sure that\n            //this does not go for stack overflow\n            currentRequestCount++;\n            setTimeout(() => {\n                handleFetchCalls(...latestReqObject);\n            },100)\n        }\n\n    }\n\n    return {\n        fetch\n    }\n})();\n\n\nexport default ThresholdFetchService;"]},"metadata":{},"sourceType":"module"}